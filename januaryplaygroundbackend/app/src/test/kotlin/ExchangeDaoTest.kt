/*
 * This source file was generated by the Gradle 'init' task
 */

import com.iainschmitt.januaryplaygroundbackend.shared.MarketOrderRequest
import com.iainschmitt.januaryplaygroundbackend.shared.OrderBookEntry
import com.iainschmitt.januaryplaygroundbackend.shared.OrderType
import com.iainschmitt.januaryplaygroundbackend.shared.TradeType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

private const val testTicker = "testTicker"


class ExchangeDaoTest {
    private lateinit var testDb: DatabaseHelper
    private lateinit var exchangeDao: ExchangeDao

    @BeforeEach
    fun setup() {
        testDb = TestDatabaseHelper(":memory:")
        exchangeDao = ExchangeDao(testDb)
        createTestSchema()
    }

    private fun createTestSchema() {
        testDb.query { conn ->
            conn.createStatement().use { stmt ->
                stmt.execute("""
                    create table order_records
                    (
                        id            INTEGER            not null
                            constraint pending_order_pk
                                primary key,
                        user          text               not null,
                        ticker        text               not null,
                        trade_type    integer default 0  not null,
                        size          integer default 0  not null,
                        price         integer default 0  not null,
                        order_type    integer default 0  not null,
                        filled_tick   integer default -1 not null,
                        received_tick integer default -1 not null
                    );
                """)
                stmt.execute("""
                    create table user
                    (
                        email           TEXT              not null
                            unique,
                        password_hash   TEXT,
                        balance         integer default 0,
                        is_admin        integer default 0 not null,
                        orchestrated_by TEXT
                    );
                """)
                stmt.execute("""
                    create table position_records
                    (
                        id            INTEGER            not null
                            constraint position_pk
                                primary key,
                        user          text               not null,
                        ticker        text               not null,
                        position_type integer            not null,
                        size          integer default 0  not null,
                        received_tick integer default -1 not null
                    );
                    )
                """)
                stmt.execute("""
                    create unique index idx_position_unique
                        on position_records (user, ticker, position_type);
                """.trimIndent())
            }
        }
    }

    @Test
    fun `fillOrder should handle buy order with partial fill correctly`() {
        insertBuyTestData()
        val buyOrder = MarketOrderRequest("incomingOrder", "buyer@test.com", testTicker, 4, TradeType.BUY, OrderType.Market)

        val marketOrderProposal = arrayListOf(
            OrderBookEntry(
                id = 1,
                user = "seller1@test.com",
                ticker = testTicker,
                tradeType = TradeType.SELL,
                size = 2,
                price = 150,
                orderType = OrderType.Limit,
                receivedTick = System.currentTimeMillis() - 2000,
                finalSize = 0
            ),
            OrderBookEntry( //Partially fill
                id = 2,
                user = "seller2@test.com",
                ticker = testTicker,
                tradeType = TradeType.SELL,
                size = 5,
                price = 160,
                orderType = OrderType.Limit,
                receivedTick = System.currentTimeMillis() - 1000,
                finalSize = 3
            )
        )

        val result = exchangeDao.fillOrder(buyOrder, marketOrderProposal)

        assertNotNull(result)

        testDb.query { conn ->
            conn.prepareStatement("SELECT filled_tick FROM order_records WHERE id = ?").use { stmt ->
                stmt.setInt(1, 1)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertTrue(rs.getLong("filled_tick") > 0)
            }

            conn.prepareStatement("SELECT size FROM order_records WHERE id = ?").use { stmt ->
                stmt.setInt(1, 2)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(3, rs.getInt("size"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "buyer@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(9380, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "seller1@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(5300, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "seller2@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(8320, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT size FROM position_records WHERE user = ? AND ticker = ?").use { stmt ->
                stmt.setString(1, "seller1@test.com")
                stmt.setString(2, testTicker)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(8, rs.getInt("size"))
            }

            conn.prepareStatement("SELECT size FROM position_records WHERE user = ? AND ticker = ?").use { stmt ->
                stmt.setString(1, "seller2@test.com")
                stmt.setString(2, testTicker)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(13, rs.getInt("size"))
            }
        }
    }

    private fun insertBuyTestData() {
        testDb.query { conn ->
            conn.prepareStatement("INSERT INTO user (email, balance) VALUES (?, ?)").use { stmt ->
                stmt.setString(1, "buyer@test.com")
                stmt.setInt(2, 10000)
                stmt.executeUpdate()

                stmt.setString(1, "seller1@test.com")
                stmt.setInt(2, 5000)
                stmt.executeUpdate()

                stmt.setString(1, "seller2@test.com")
                stmt.setInt(2, 8000)
                stmt.executeUpdate()
            }

            conn.prepareStatement("INSERT INTO order_records (id, size, filled_tick, user, ticker, price) VALUES (?, ?, ?, ?, ?, ?)").use { stmt ->
                stmt.setInt(1, 1)
                stmt.setInt(2, 2)
                stmt.setLong(3, 0)
                stmt.setString(4, "seller1@test.com")
                stmt.setString(5, testTicker)
                stmt.setInt(6, 150)
                stmt.executeUpdate()

                stmt.setInt(1, 2)
                stmt.setInt(2, 5)
                stmt.setLong(3, 0)
                stmt.setString(4, "seller2@test.com")
                stmt.setString(5, testTicker)
                stmt.setInt(6, 160)
                stmt.executeUpdate()
            }

            conn.prepareStatement("INSERT INTO position_records (user, ticker, position_type, size, received_tick) VALUES (?, ?, ?, ?, ?)").use { stmt ->
                stmt.setString(1, "seller1@test.com")
                stmt.setString(2, testTicker)
                stmt.setInt(3, 0)
                stmt.setInt(4, 10)
                stmt.setLong(5, System.currentTimeMillis() - 1000)
                stmt.executeUpdate()

                stmt.setString(1, "seller2@test.com")
                stmt.setString(2, testTicker)
                stmt.setInt(3, 0)
                stmt.setInt(4, 15)
                stmt.setLong(5, System.currentTimeMillis() - 500)
                stmt.executeUpdate()
            }
        }
    }

    @Test
    fun `fillOrder should handle sell order with partial fill correctly`() {
        insertSellTestDatat()
        val sellOrder = MarketOrderRequest("incomingOrder", "seller@test.com", testTicker, 4, TradeType.SELL, OrderType.Market)

        val marketOrderProposal = arrayListOf(
            OrderBookEntry(
                id = 3,
                user = "buyer1@test.com",
                ticker = testTicker,
                tradeType = TradeType.BUY,
                size = 2,
                price = 140,
                orderType = OrderType.Limit,
                receivedTick = System.currentTimeMillis() - 2000,
                finalSize = 0
            ),
            OrderBookEntry(
                id = 4,
                user = "buyer2@test.com",
                ticker = testTicker,
                tradeType = TradeType.BUY,
                size = 5,
                price = 130,
                orderType = OrderType.Limit,
                receivedTick = System.currentTimeMillis() - 1000,
                finalSize = 3
            )  // Partial fill
        )

        val result = exchangeDao.fillOrder(sellOrder, marketOrderProposal)

        assertNotNull(result)

        testDb.query { conn ->
            conn.prepareStatement("SELECT filled_tick FROM order_records WHERE id = ?").use { stmt ->
                stmt.setInt(1, 3)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertTrue(rs.getLong("filled_tick") > 0)
            }

            conn.prepareStatement("SELECT size FROM order_records WHERE id = ?").use { stmt ->
                stmt.setInt(1, 4)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(3, rs.getInt("size"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "seller@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(6540, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "buyer1@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(4720, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT balance FROM user WHERE email = ?").use { stmt ->
                stmt.setString(1, "buyer2@test.com")
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(6740, rs.getInt("balance"))
            }

            conn.prepareStatement("SELECT size FROM position_records WHERE user = ? AND ticker = ?").use { stmt ->
                stmt.setString(1, "seller@test.com")
                stmt.setString(2, testTicker)
                val rs = stmt.executeQuery()
                assertTrue(rs.next())
                assertEquals(16, rs.getInt("size"))
            }
        }
    }

    private fun insertSellTestDatat() {
        testDb.query { conn ->
            conn.prepareStatement("INSERT INTO user (email, balance) VALUES (?, ?)").use { stmt ->
                stmt.setString(1, "seller@test.com")
                stmt.setInt(2, 6000)
                stmt.executeUpdate()

                stmt.setString(1, "buyer1@test.com")
                stmt.setInt(2, 5000)
                stmt.executeUpdate()

                stmt.setString(1, "buyer2@test.com")
                stmt.setInt(2, 7000)
                stmt.executeUpdate()
            }

            conn.prepareStatement("INSERT INTO order_records (id, size, filled_tick, user, ticker, price) VALUES (?, ?, ?, ?, ?, ?)").use { stmt ->
                stmt.setInt(1, 3)
                stmt.setInt(2, 2)
                stmt.setLong(3, 0)
                stmt.setString(4, "buyer1@test.com")
                stmt.setString(5, testTicker)
                stmt.setInt(6, 140)
                stmt.executeUpdate()

                stmt.setInt(1, 4)
                stmt.setInt(2, 5)
                stmt.setLong(3, 0)
                stmt.setString(4, "buyer2@test.com")
                stmt.setString(5, testTicker)
                stmt.setInt(6, 130)
                stmt.executeUpdate()
            }

            conn.prepareStatement("INSERT INTO position_records (user, ticker, position_type, size, received_tick) VALUES (?, ?, ?, ?, ?)").use { stmt ->
                stmt.setString(1, "seller@test.com")
                stmt.setString(2, testTicker)
                stmt.setInt(3, 0)
                stmt.setInt(4, 20)
                stmt.setLong(5, System.currentTimeMillis() - 1000)
                stmt.executeUpdate()
            }
        }
    }
}